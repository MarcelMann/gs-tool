<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE gswb PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "jar:org/miv/graphstream/tool/workbench/xml/graphstream-workbench.dtd">
<gswb:algorithms xmlns="org/miv/graphstream" xmlns:gswb="workbench">
	<algorithm name="APSP" class="org.miv.graphstream.algorithm.APSP" category="default">
		<description>
		<![CDATA[
		<h2>The APSP algorithm</h2>
		<p>This class defines algorithms that compute all shortest<br/>
		paths lengths between all pair of nodes in a given graph.<br/>
		This algorithm uses the Floyd-Warshal algorithm, that<br/>
		effectively runs in O(n^3). This may seems a very large<br/>
		complexity, however this algorithm may perform better than<br/>
		running several Dijkstra on all node pairs of the graph when<br/>
		the graph becomes dense.</p>
		]]>
		</description>
		<parameter name="weightAttributeName" type="java.lang.String"/>
		<parameter name="directed" type="boolean"/>
	</algorithm>
	<algorithm name="AStar" class="org.miv.graphstream.algorithm.AStar" category="default">
		<description>
		<![CDATA[
		<h2>The A* algorithm</h2>
		<p>A* computes the shortest path from a node to another in a<br/>
		graph. It can eventually fail if the two nodes are in two<br/>
		distinct connected components.</p>
		]]>
		</description>
		<parameter name="source" type="nodeid"/>
		<parameter name="target" type="nodeid"/>
	</algorithm>
	<algorithm name="BellmanFord" class="org.miv.graphstream.algorithm.BellmanFord" category="default">
		<description>
		<![CDATA[
		<h2>The BellmanFord algorithm</h2>
		<p>The BellmanFord algorithm computes single-source shortest<br/>
		paths in a weighted digraph (where some of the edge weights<br/>
		may be negative). Dijkstra's algorithm accomplishes the same<br/>
		problem with a lower running time, but requires edge weights<br/>
		to be non-negative. Thus, BellmanFord is usually used only<br/>
		when there are negative edge weights.</p>
		]]>
		</description>
		<parameter name="attribute" type="java.lang.String"/>
		<parameter name="source" type="java.lang.String"/>
	</algorithm>
	<algorithm name="Dijkstra"
		class="org.miv.graphstream.algorithm.Dijkstra" category="default">
		<description>
		<![CDATA[
		<h2>The Dijkstra algorithm</h2>
		<p>Dijkstra's algorithm is a greedy algorithm that solves the single-source<br/>
		shortest path problem for a directed graph with non negative edge weights (<br/>
		<a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Wikipedia</a>).</p>
		<p>This length can be the absolute length of the path ( a path with 3 edges has<br/>
		a length of 3), it can also be computed considering other constraints<br/>
		situated on the edges or on the nodes.</p>
		<p>Note that Dijkstra's algorithm only computes with non-negative values.</p>
		]]>
		</description>
		<parameter name="elementType" type="org.miv.graphstream.algorithm.Dijkstra$Element"></parameter>
		<parameter name="attribute" type="java.lang.String"></parameter>
		<parameter name="root" type="node"></parameter>
	</algorithm>
	<algorithm name="Kruskal" class="org.miv.graphstream.algorithm.Kruskal" category="default">
		<description>
		<![CDATA[
		<h2>The Kruskal algorithm</h2>
		<p>Kruskal's algorithm is a greedy algorithm which allows to find a minimal<br/>
		spanning tree in a weighted connected graph. More informations on<br/>
		<a href="http://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Wikipedia</a>.</p>
		]]>
		</description>
		<parameter name="weightAttribute" type="java.lang.String" default="weight"></parameter>
		<parameter name="flagAttribute" type="java.lang.String" default="Kruskal.flag"></parameter>
		<parameter name="flagOn" type="java.lang.Object" default="true"></parameter>
		<parameter name="flagOff" type="java.lang.Object" default="false"></parameter>
	</algorithm>
	<algorithm name="Prim" class="org.miv.graphstream.algorithm.Prim" category="default">
		<description>
		<![CDATA[
		<h2>The Prim algorithm</h2>
		<p>Prim's algorithm is an algorithm which allows to find a minimal<br/>
		spanning tree in a weighted connected graph. More informations on<br/>
		<a href="http://en.wikipedia.org/wiki/Prim%27s_algorithm">Wikipedia</a>.</p>
		]]>
		</description>
		<parameter name="weightAttribute" type="java.lang.String" default="weight"></parameter>
		<parameter name="flagAttribute" type="java.lang.String" default="Kruskal.flag"></parameter>
		<parameter name="flagOn" type="java.lang.Object" default="true"></parameter>
		<parameter name="flagOff" type="java.lang.Object" default="false"></parameter>
	</algorithm>
	
	<!--Coloring-->
	<algorithm name="WelshPowell" class="org.miv.graphstream.algorithm.coloring.WelshPowell" category="coloring">
		<description>
		<![CDATA[
		<h2>The Welsh and Powell algorithm</h2>
		<p>This class is intended to give some algorithm for computing<br/>
		the well-known coloring problem. It provides the Welsh and<br/>
		Powell greedy algorithm that may used as a static method.</p>
		]]>
		</description>
		<parameter name="modify" type="boolean" default="true"/>
		<parameter name="attribute" type="java.lang.String" default="ui.color" />
	</algorithm>
	
	<!--Measure-->
	<algorithm name="GraphNervousness" class="org.miv.graphstream.algorithm.measure.GraphNervousness" category="measure">
		<description>
		<![CDATA[
		<h2>The graph nervousness measure</h2>
		<p>The graph nervousness is a measure that give for each step<br/>
		of a dynamic graph a ratio between the number of structural<br/>
		events ( addition and removal of nodes and edges) and the<br/>
		number of elements (nodes and edges) in the graph.<br/>
		<br/>
		This measure is different from the Element Nervousness even<br/>
		different from the average element nervousness.</p>
		]]>
		</description>
	</algorithm>
	<!--Generators--><algorithm name="RandomGenerator" class="org.miv.graphstream.algorithm.generator.RandomGenerator" category="generator">
		<description>
		<![CDATA[
		<h2>The random generator</h2>
		<p>This generator creates random graphs of any size. Calling<br/>
		begin(Graph) put one unique node in the graph, then<br/>
		nextElement() will add a new node each time it is called and<br/>
		connect this node randomly to others.</p>
		]]>
		</description>
		<parameter name="averageDegree" type="int" />
		<parameter name="directed" type="boolean" />
		<parameter name="randomlyDirectedEdges" type="boolean" />
	</algorithm><algorithm name="GridGenerator"
		class="org.miv.graphstream.algorithm.generator.GridGenerator"
		category="generator">
		<description>
		<![CDATA[
		<h2>The grid generator</h2>
		<p>Generator for grids.</p>
		]]>
		</description>
		<parameter name="cross" type="boolean"></parameter>
		<parameter name="tore" type="boolean"></parameter>
		<parameter name="generateXY" type="boolean"></parameter>
		<parameter name="directed" type="boolean"></parameter>
	</algorithm>
	<algorithm name="DorogovtsevMendesGenerator"
		class="org.miv.graphstream.algorithm.generator.DorogovtsevMendesGenerator"
		category="generator">
		<description>
		<![CDATA[
		<h2>The Dorogovtsev Mendes generator</h2>
		<p>Generates a graph using the Dorogovtsev - Mendes algorithm. This starts by<br/>
		creating three nodes and tree edges, making a triangle, and then add one<br/>
		node at a time. Each time a node is added, an edge is choosed randomly and<br/>
		the node is connected to the two extremities of this edge.</p>
		]]>
		</description>
	</algorithm>
	<algorithm name="FullGenerator"
		class="org.miv.graphstream.algorithm.generator.FullGenerator"
		category="generator">
		<description>
		<![CDATA[
		<h2>Full generator</h2>
		<p>Probably not very usefull, still sometimes needed. This genertor creates<br/>
		fully connected graphs of any size. Calling {@link #begin(Graph)} put one<br/>
		unique node in the graph, then {@link #nextElement()} will add a new node<br/>
		each time it is called.</p>
		<p>This generator has the ability to add randomly choosed numerical values<br/>
		on arbitrary attributes on edges or nodes of the graph, and to randomly<br/>
		choose a direction for edges.</p>
		<p>A list of attributes can be given for nodes and edges. In this case each<br/>
		new node or edge added will have this attribute and the value will be a<br/>
		randomly choosed number. The range in which these numbers are choosed can be<br/>
		specified.</p>
		<p>By default, edges are not oriented. It is possible to ask orientation, in<br/>
		which case the direction is choosed randomly.</p>
		]]>
		</description>
		<parameter name="directed" type="boolean"></parameter>
		<parameter name="randomlyDirectedEdges" type="boolean"></parameter>
		<parameter name="nodeAttribute" type="java.lang.String"></parameter>
		<parameter name="edgeAttribute" type="java.lang.String"></parameter>
	</algorithm>
	<algorithm name="IncompleteGridGenerator" class="org.miv.graphstream.algorithm.generator.IncompleteGridGenerator" category="generator">
		<description>
		<![CDATA[
		<h2>Incomplete grid generator</h2>
		<p>This class allow the user to generate 2D-grid graph into the dgs format.</p>
		<br/>
		<p>This is a very simple graph generator that generates a grid of size nXm.<br/>
		However, four different versions are possible:
		<ol>
		<li> The simple 2D-grid, in such a case, two parameters (width and height) are enough</li>
		<li> The 2D-Cross-Grid, in which inner nodes have 8 neighbors (North, South, East, West,<br/>
		North-West, North-East, South-West and South-East).</li>
		<li> The 2D-Torus, in which all nodes have 4 neighbors, and,</li>
		<li> The 2D-Cross-Torus, in which all nodes have 8 neighbors.</li>
		</ol></p>
		]]>
		</description>
		<parameter name="width" type="int"></parameter>
		<parameter name="height" type="int"></parameter>
		<parameter name="cross" type="boolean"></parameter>
		<parameter name="torus" type="boolean"></parameter>
		<parameter name="nbObstacles" type="int"></parameter>
		<parameter name="obstacleSize" type="int"></parameter>
	</algorithm>
	<algorithm name="PreferentialAttachmentGenerator" class="org.miv.graphstream.algorithm.generator.PreferentialAttachmentGenerator" category="generator">
		<description>
		<![CDATA[
		<h2>The Preferential Attachment generator</h2>
		<p>Scale-free graph (tree) generator using the preferential attachement rule.</p>
		<br/>
		<p>This is a very simple graph generator that generates a tree using the<br/>
		preferential attachement rule: nodes are generated one by one, and each time<br/>
		attached by an edge to another node that has more chance to choosed if it<br/>
		already has lots of nodes attached to it.</p>
		<p>The more this generator is iterated, the more nodes are generated. It can<br/>
		therefore generate trees of any size.</p>
		]]>
		</description>
	</algorithm>
	<algorithm name="RandomEuclideanGenerator" class="org.miv.graphstream.algorithm.generator.RandomEuclideanGenerator" category="generator">
		<description>
		<![CDATA[
		<h2>Random Euclidean graph generator.</h2>
		<p>This generator creates random graphs of any size. Links of such graphs are<br/>
		created according to a threshold. If the Euclidean distance between two nodes<br/>
		is less than a given threshold, then a link is created between those 2 nodes.<br/>
		Calling {@link #begin(Graph)} put one unique node in the graph, then<br/>
		{@link #nextElement()} will add a new node each time it is called and connect<br/>
		this node to its neighbors according to the threshold planar Euclidean<br/>
		distance.</p
		><br/>
		<p>This generator has the ability to add randomly chosen numerical values on<br/>
		arbitrary attributes on edges or nodes of the graph, and to randomly choose a<br/>
		direction for edges.</p>
		<br/>
		<p>A list of attributes can be given for nodes and edges. In this case each new<br/>
		node or edge added will have this attribute and the value will be a randomly<br/>
		chosen number. The range in which these numbers are chosen can be specified.</p>
		<br/>
		<p>By default, edges are not oriented. It is possible to ask orientation, in<br/>
		which case the direction is chosen randomly.</p>
		<br/>
		<p>By default, the graph is generated in the plane (2 dimensions) . Cartesian<br/>
		coordinates on nodes will be generated at random. So, each node will<br/>
		automatically be given two attributes: "x" and "y". If a dimension is<br/>
		specified, then |dimension| attributes are generated, and the 2-norm distance (<br/>
		<a href="http://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a>)<br/>
		is considered in that dimension between the nodes.</p>
		<br/>
		<p>If the dimension is 2, then attributes "x" and "y" are defined for each node.<br/>
		If dimension is 3, then attributes "x", "y" and "z" are used. For other<br/>
		values of dimension, |dimension| attributes are defined ("xi" with "i" \in<br/>
		|dimension|) .</p>
		]]>
		</description>
		<parameter name="dimension" type="int"></parameter>
		<parameter name="directed" type="boolean"></parameter>
		<parameter name="randomlyDirectedEdges" type="boolean"></parameter>
		<parameter name="nodeAttribute" type="java.lang.String"></parameter>
		<parameter name="edgeAttribute" type="java.lang.String"></parameter>
	</algorithm>
</gswb:algorithms>
